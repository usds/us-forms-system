{"version":3,"sources":["../../../src/js/state/helpers.js"],"names":["updateRequiredFields","isContentExpanded","setHiddenFields","removeHiddenData","updateSchemaFromUiSchema","replaceRefSchemas","updateItemsSchema","updateSchemaAndData","recalculateSchemaAndData","createInitialState","isHiddenField","schema","get","path","data","reduce","current","next","uiSchema","formData","index","type","newRequired","Object","keys","properties","requiredArray","nextProp","field","isRequired","arrayHasField","some","prop","filter","concat","required","newSchema","currentSchema","nextSchema","length","newItemSchemas","items","map","item","idx","newItem","matcher","containingObject","slice","updatedSchema","hideIf","expandUnder","expandUnderCondition","newProperties","undefined","nextData","newItems","updateSchema","newSchemaProps","definitions","Error","$ref","refPath","replace","split","definition","fieldData","Array","isArray","additionalItems","fillIn","fill","updatedItems","newData","initialState","pages","state","pageKey","page","newState","showPagePerItem","arrayData","arrayPath","editMode","formConfig","submission","status","errorMessage","id","timestamp","hasAttemptedSubmit","formId","loadedData","metadata","reviewPageView","openChapters","viewedPages","Set","pageAndDataState","defaultDefinitions","isArrayPage","initialData","itemFilter"],"mappings":"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","file":"helpers.js","sourcesContent":["import _ from 'lodash/fp';\nimport { getDefaultFormState } from '@department-of-veterans-affairs/react-jsonschema-form/lib/utils';\n\nimport {\n  checkValidSchema,\n  createFormPageList\n} from '../helpers';\n\nfunction isHiddenField(schema) {\n  return !!schema['ui:collapsed'] || !!schema['ui:hidden'];\n}\n\nfunction get(path, data) {\n  return path.reduce((current, next) => {\n    return typeof current === 'undefined' ? current : current[next];\n  }, data);\n}\n\n/*\n * This function goes through a schema/uiSchema and updates the required array\n * based on any ui:required field properties in the uiSchema.\n *\n * If no required fields are changing, it makes sure to not mutate the existing schema,\n * so we can still take advantage of any shouldComponentUpdate optimizations\n */\nexport function updateRequiredFields(schema, uiSchema, formData, index = null) {\n  if (!uiSchema) {\n    return schema;\n  }\n\n  if (schema.type === 'object') {\n    const newRequired = Object.keys(schema.properties).reduce((requiredArray, nextProp) => {\n      const field = uiSchema[nextProp];\n      if (field && field['ui:required']) {\n        const isRequired = field['ui:required'](formData, index);\n        const arrayHasField = requiredArray.some(prop => prop === nextProp);\n\n        if (arrayHasField && !isRequired) {\n          return requiredArray.filter(prop => prop !== nextProp);\n        } else if (!arrayHasField && isRequired) {\n          return requiredArray.concat(nextProp);\n        }\n\n        return requiredArray;\n      }\n\n      return requiredArray;\n    }, schema.required || []);\n\n    const newSchema = Object.keys(schema.properties).reduce((currentSchema, nextProp) => {\n      if (uiSchema) {\n        const nextSchema = updateRequiredFields(currentSchema.properties[nextProp], uiSchema[nextProp], formData, index);\n        if (nextSchema !== currentSchema.properties[nextProp]) {\n          return _.set(['properties', nextProp], nextSchema, currentSchema);\n        }\n      }\n\n      return currentSchema;\n    }, schema);\n\n    if (newSchema.required !== newRequired && (newSchema.required || newRequired.length > 0)) {\n      return _.set('required', newRequired, newSchema);\n    }\n\n    return newSchema;\n  }\n\n  if (schema.type === 'array') {\n    // each item has its own schema, so we need to update the required fields on those schemas\n    // and then check for differences\n    const newItemSchemas = schema.items.map((item, idx) => updateRequiredFields(item, uiSchema.items, formData, idx));\n    if (newItemSchemas.some((newItem, idx) => newItem !== schema.items[idx])) {\n      return _.set('items', newItemSchemas, schema);\n    }\n  }\n\n  return schema;\n}\n\nexport function isContentExpanded(data, matcher) {\n  if (typeof matcher === 'undefined') {\n    return !!data;\n  } else if (typeof matcher === 'function') {\n    return matcher(data);\n  }\n\n  return data === matcher;\n}\n\n/*\n * This steps through a schema and sets any fields to hidden, based on a\n * hideIf function from uiSchema and the current page data. Sets 'ui:hidden'\n * which is a non-standard JSON Schema property\n *\n * The path parameter will contain the path, relative to formData, to the\n * form data corresponding to the current schema object\n */\nexport function setHiddenFields(schema, uiSchema, formData, path = []) {\n  if (!uiSchema) {\n    return schema;\n  }\n\n  // expandUnder fields are relative to the parent object of the current\n  // field, so get that object using path here\n  const containingObject = get(path.slice(0, -1), formData) || formData;\n\n  let updatedSchema = schema;\n  const hideIf = get(['ui:options', 'hideIf'], uiSchema);\n  const index = path.reduce((current, next) => {\n    return typeof next === 'number' ? next : current;\n  }, null);\n\n  if (hideIf && hideIf(formData, index)) {\n    if (!updatedSchema['ui:hidden']) {\n      updatedSchema = _.set('ui:hidden', true, updatedSchema);\n    }\n  } else if (updatedSchema['ui:hidden']) {\n    updatedSchema = _.unset('ui:hidden', updatedSchema);\n  }\n\n  const expandUnder = get(['ui:options', 'expandUnder'], uiSchema);\n  const expandUnderCondition = get(['ui:options', 'expandUnderCondition'], uiSchema);\n  if (expandUnder && !isContentExpanded(containingObject[expandUnder], expandUnderCondition)) {\n    if (!updatedSchema['ui:collapsed']) {\n      updatedSchema = _.set('ui:collapsed', true, updatedSchema);\n    }\n  } else if (updatedSchema['ui:collapsed']) {\n    updatedSchema = _.unset('ui:collapsed', updatedSchema);\n  }\n\n  if (updatedSchema.type === 'object') {\n    const newProperties = Object.keys(updatedSchema.properties).reduce((current, next) => {\n      const newSchema = setHiddenFields(updatedSchema.properties[next], uiSchema[next], formData, path.concat(next));\n\n      if (newSchema !== updatedSchema.properties[next]) {\n        return _.set(next, newSchema, current);\n      }\n\n      return current;\n    }, updatedSchema.properties);\n\n    if (newProperties !== updatedSchema.properties) {\n      return _.set('properties', newProperties, updatedSchema);\n    }\n  }\n\n  if (updatedSchema.type === 'array') {\n    // each item has its own schema, so we need to update the required fields on those schemas\n    // and then check for differences\n    const newItemSchemas = updatedSchema.items.map((item, idx) =>\n      setHiddenFields(item, uiSchema.items, formData, path.concat(idx))\n    );\n\n    if (newItemSchemas.some((newItem, idx) => newItem !== updatedSchema.items[idx])) {\n      return _.set('items', newItemSchemas, updatedSchema);\n    }\n  }\n\n  return updatedSchema;\n}\n\n/*\n * Steps through data and removes any fields that are marked as hidden\n * This is done so that hidden fields don’t cause validation errors that\n * a user can’t see.\n */\nexport function removeHiddenData(schema, data) {\n  // null is necessary here because Rails 4 will convert empty arrays to null\n  // In the forms, there's no difference between an empty array and null or undefined\n  if (isHiddenField(schema) || typeof data === 'undefined' || data === null) {\n    return undefined;\n  }\n\n  if (schema.type === 'object') {\n    return Object.keys(data).reduce((current, next) => {\n      if (typeof data[next] !== 'undefined' && schema.properties[next]) {\n        const nextData = removeHiddenData(schema.properties[next], data[next]);\n\n        // if the data was removed, then just unset it\n        if (typeof nextData === 'undefined') {\n          return _.unset(next, current);\n        }\n\n        // if data was updated (like a nested prop was removed), update it\n        if (nextData !== data[next]) {\n          return _.set(next, nextData, current);\n        }\n      }\n\n      return current;\n    }, data);\n  }\n\n  if (schema.type === 'array') {\n    const newItems = data.map((item, index) => {\n      return removeHiddenData(schema.items[index], item);\n    });\n\n    if (newItems.some((newItem, idx) => newItem !== data[idx])) {\n      return newItems;\n    }\n\n    return data;\n  }\n\n  return data;\n}\n\n/*\n * This is similar to the hidden fields schema function above, except more general.\n * It will step through a schema and replace parts of it based on an updateSchema\n * function in uiSchema. This means the schema can be re-calculated based on data\n * a user has entered.\n */\nexport function updateSchemaFromUiSchema(schema, uiSchema, formData, index = null, path = []) {\n  if (!uiSchema) {\n    return schema;\n  }\n\n  let currentSchema = schema;\n\n  if (currentSchema.type === 'object') {\n    const newSchema = Object.keys(currentSchema.properties).reduce((current, next) => {\n      const nextProp = updateSchemaFromUiSchema(current.properties[next], uiSchema[next], formData, index, path.concat(next));\n\n      if (current.properties[next] !== nextProp) {\n        return _.set(['properties', next], nextProp, current);\n      }\n\n      return current;\n    }, currentSchema);\n\n    if (newSchema !== schema) {\n      currentSchema = newSchema;\n    }\n  }\n\n  if (currentSchema.type === 'array') {\n    // each item has its own schema, so we need to update the required fields on those schemas\n    // and then check for differences\n    const newItemSchemas = currentSchema.items.map((item, idx) =>\n      updateSchemaFromUiSchema(item, uiSchema.items, formData, idx, path.concat(idx))\n    );\n\n    if (newItemSchemas.some((newItem, idx) => newItem !== currentSchema.items[idx])) {\n      currentSchema = _.set('items', newItemSchemas, currentSchema);\n    }\n  }\n\n  const updateSchema = get(['ui:options', 'updateSchema'], uiSchema);\n\n  if (updateSchema) {\n    const newSchemaProps = updateSchema(formData, currentSchema, uiSchema, index, path);\n\n    const newSchema = Object.keys(newSchemaProps).reduce((current, next) => {\n      if (newSchemaProps[next] !== schema[next]) {\n        return _.set(next, newSchemaProps[next], current);\n      }\n\n      return current;\n    }, currentSchema);\n\n    if (newSchema !== currentSchema) {\n      return newSchema;\n    }\n  }\n\n  return currentSchema;\n}\n\nexport function replaceRefSchemas(schema, definitions, path = '') {\n  // this can happen if you import a field that doesn’t exist from a schema\n  if (!schema) {\n    throw new Error(`Schema is undefined at ${path}`);\n  }\n  if (schema.$ref) {\n    // There’s a whole spec for JSON pointers, but we don’t use anything more complicated\n    // than this so far\n    const refPath = schema.$ref.replace('#/definitions/', '').split('/');\n    const definition = get(refPath, definitions);\n    if (!definition) {\n      throw new Error(`Missing definition for ${schema.$ref} at ${path}. You probably need to add it to defaultDefinitions`);\n    }\n\n    return replaceRefSchemas(definition, definitions, path);\n  }\n\n  if (schema.type === 'object') {\n    const newSchema = Object.keys(schema.properties).reduce((current, next) => {\n      const nextProp = replaceRefSchemas(schema.properties[next], definitions, `${path}.${next}`);\n\n      if (current.properties[next] !== nextProp) {\n        return _.set(['properties', next], nextProp, current);\n      }\n\n      return current;\n    }, schema);\n\n    return newSchema;\n  }\n\n  if (schema.type === 'array') {\n    const newItems = replaceRefSchemas(schema.items, definitions, `${path}.items`);\n\n    if (newItems !== schema.items) {\n      return _.set('items', newItems, schema);\n    }\n  }\n\n  return schema;\n}\n\n/**\n * This function updates an array schema to use the array of\n * item schema format and keeps that array in sync with the\n * data in that array in the form data.\n *\n * This allows us to have conditional fields for each array item,\n * because our conditional field implementation depends on modifying\n * schemas\n *\n * @param {Object} schema The current JSON Schema object\n * @param {any} fieldData The data associated with the current schema\n */\nexport function updateItemsSchema(schema, fieldData = null) {\n  if (schema.type === 'array') {\n    let newSchema = schema;\n\n    // This happens the first time this function is called when\n    // generating the form\n    if (!Array.isArray(schema.items)) {\n      newSchema = _.assign(schema, {\n        items: [],\n        additionalItems: schema.items\n      });\n    }\n\n    if (!fieldData) {\n      // If there’s no data, the list of schemas should be empty\n      newSchema = _.set('items', [], newSchema);\n    } else if (fieldData.length > newSchema.items.length) {\n      // Here we’re filling in the items array to make it the same\n      // length as the array of form data. This happens when you add\n      // another record on the form, mainly.\n      const fillIn = Array(fieldData.length - newSchema.items.length)\n        .fill(newSchema.additionalItems);\n      newSchema = _.set('items', newSchema.items.concat(fillIn), newSchema);\n    } else if (fieldData.length < newSchema.items.length) {\n      // If someone removed a record we’re removing the last schema item\n      // This may not be the actual removed schema, but the schemas will\n      // always be updated in the next step\n      newSchema = _.set('items', _.dropRight(1, newSchema.items), newSchema);\n    }\n\n    const updatedItems = newSchema.items.map(\n      (item, index) => updateItemsSchema(item, fieldData[index])\n    );\n    if (newSchema.items.some((item, index) => item !== updatedItems[index])) {\n      return _.set('items', updatedItems, newSchema);\n    }\n\n    return newSchema;\n  }\n\n  if (schema.type === 'object') {\n    const newSchema = Object.keys(schema.properties).reduce((current, next) => {\n      const nextProp = updateItemsSchema(schema.properties[next], fieldData ? fieldData[next] : null);\n\n      if (current.properties[next] !== nextProp) {\n        return _.set(['properties', next], nextProp, current);\n      }\n\n      return current;\n    }, schema);\n\n    return newSchema;\n  }\n\n  return schema;\n}\n\n/**\n * This is the main sequence of updates that happens when data is changed\n * on a form. Most updates are applied to the schema, except that the data\n * is updated to remove newly hidden data\n *\n * @param {Object} schema The current JSON Schema\n * @param {Object} uiSchema The current UI Schema (does not change)\n * @param {Object} formData Flattened data for the entire form\n */\nexport function updateSchemaAndData(schema, uiSchema, formData) {\n  let newSchema = updateItemsSchema(schema, formData);\n  newSchema = updateRequiredFields(newSchema, uiSchema, formData);\n\n  // Update the schema with any fields that are now hidden because of the data change\n  newSchema = setHiddenFields(newSchema, uiSchema, formData);\n\n  // Update the schema with any general updates based on the new data\n  newSchema = updateSchemaFromUiSchema(newSchema, uiSchema, formData);\n\n  // Remove any data that’s now hidden in the schema\n  const newData = removeHiddenData(newSchema, formData);\n\n  // We need to do this again because array data might have been removed\n  newSchema = updateItemsSchema(newSchema, newData);\n\n  checkValidSchema(newSchema);\n\n  return {\n    data: newData,\n    schema: newSchema\n  };\n}\n\nexport function recalculateSchemaAndData(initialState) {\n  return Object.keys(initialState.pages)\n    .reduce((state, pageKey) => {\n      // on each data change, we need to do the following steps\n      // Recalculate any required fields, based on the new data\n      const page = state.pages[pageKey];\n      const formData = initialState.data;\n\n      const { data, schema } = updateSchemaAndData(page.schema, page.uiSchema, formData);\n\n      let newState = state;\n\n      if (formData !== data) {\n        newState = _.set('data', data, state);\n      }\n\n      if (page.schema !== schema) {\n        newState = _.set(['pages', pageKey, 'schema'], schema, newState);\n      }\n\n      if (page.showPagePerItem) {\n        const arrayData = _.get(page.arrayPath, newState.data) || [];\n        // If an item was added or removed for the data used by a showPagePerItem page,\n        // we have to reset everything because we can’t match the edit states to rows directly\n        // This will rarely ever be noticeable\n        if (page.editMode.length !== arrayData.length) {\n          newState = _.set(['pages', pageKey, 'editMode'], arrayData.map(() => false), newState);\n        }\n      }\n\n      return newState;\n    }, initialState);\n}\n\nexport function createInitialState(formConfig) {\n  let initialState = {\n    submission: {\n      status: false,\n      errorMessage: false,\n      id: false,\n      timestamp: false,\n      hasAttemptedSubmit: false\n    },\n    formId: formConfig.formId,\n    loadedData: {\n      formData: {},\n      metadata: {}\n    },\n    reviewPageView: {\n      openChapters: [],\n      viewedPages: new Set()\n    }\n  };\n\n  const pageAndDataState = createFormPageList(formConfig)\n    .reduce((state, page) => {\n      const definitions = _.assign(formConfig.defaultDefinitions || {}, page.schema.definitions);\n      let schema = replaceRefSchemas(page.schema, definitions, page.pageKey);\n      // Throw an error if the new schema is invalid\n      checkValidSchema(schema);\n      schema = updateItemsSchema(schema);\n      const isArrayPage = page.showPagePerItem;\n      const data = getDefaultFormState(schema, page.initialData, schema.definitions);\n\n      /* eslint-disable no-param-reassign */\n      state.pages[page.pageKey] = {\n        uiSchema: page.uiSchema,\n        schema,\n        editMode: isArrayPage ? [] : false,\n        showPagePerItem: page.showPagePerItem,\n        arrayPath: page.arrayPath,\n        itemFilter: page.itemFilter\n      };\n\n      state.data = _.merge(state.data, data);\n      /* eslint-enable no-param-reassign */\n\n      return state;\n    }, {\n      data: {},\n      pages: {},\n    });\n\n  initialState = _.assign(initialState, pageAndDataState);\n  // Take another pass and recalculate the schema and data based on the default data\n  // We do this to avoid passing undefined for the whole form state when the form first renders\n  initialState = recalculateSchemaAndData(initialState);\n\n  return initialState;\n}\n"]}