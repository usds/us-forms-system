{"version":3,"sources":["../../../../src/js/utilities/data/set.js"],"names":["set","baseSet","arrayPath","value","object","level","length","newObj","pathSegment","nextPathSegment","Array","Error","path","isArray"],"mappings":";;;;;;;;kBAgEwBA,G;;AAhExB;;;;AACA;;;;AACA;;;;;;AAEA;;;;;;;;;;;;;;;AAeA,SAASC,OAAT,CAAiBC,SAAjB,EAA4BC,KAA5B,EAAmCC,MAAnC,EAAsD;AAAA,MAAXC,KAAW,uEAAH,CAAG;;AACpD,MAAIA,SAASH,UAAUI,MAAvB,EAA+B;AAC7B;AACA,WAAOH,KAAP;AACD;;AAED,MAAMI,SAAS,qBAAMH,MAAN,CAAf;;AAEA,MAAMI,cAAcN,UAAUG,KAAV,CAApB;AACA,MAAMI,kBAAkBP,UAAUG,QAAQ,CAAlB,CAAxB;;AAEA;AACA,MAAI,OAAOE,OAAOC,WAAP,CAAP,KAA+B,WAAnC,EAAgD;AAC9C;AACA,mBAAeC,eAAf,yCAAeA,eAAf;AACE,WAAK,QAAL;AACEF,eAAOC,WAAP,IAAsB,EAAtB;AACA;AACF,WAAK,QAAL;AACE;AACAD,eAAOC,WAAP,IAAsB,IAAIE,KAAJ,CAAUD,kBAAkB,CAA5B,CAAtB;AACA;AACF,WAAK,WAAL;AACE;AACA;AACF;AACE,cAAM,IAAIE,KAAJ,8CAAoDF,eAApD,yCAAoDA,eAApD,kDAA6GJ,QAAQ,CAArH,oBAAoII,eAApI,OAAN;AAZJ;AAcD;;AAEDF,SAAOC,WAAP,IAAsBP,QAAQC,SAAR,EAAmBC,KAAnB,EAA0BI,OAAOC,WAAP,CAA1B,EAA+CH,QAAQ,CAAvD,CAAtB;;AAEA,SAAOE,MAAP;AACD;;AAGD;;;;;;;;;AASe,SAASP,GAAT,CAAaY,IAAb,EAAmBT,KAAnB,EAA0BC,MAA1B,EAAkC;AAC/C,MAAMF,YAAYQ,MAAMG,OAAN,CAAcD,IAAd,IAAsBA,IAAtB,GAA6B,+BAAgBA,IAAhB,CAA/C;AACA,gCAAeV,SAAf;AACA,SAAOD,QAAQC,SAAR,EAAmBC,KAAnB,EAA0BC,MAA1B,EAAkC,CAAlC,CAAP;AACD","file":"set.js","sourcesContent":["import deconstructPath from './deconstructPath';\nimport clone from './clone';\nimport checkValidPath from './checkValidPath';\n\n/**\n * Same as `set`, but uses the level param to determine when to clone and give a more helpful error message.\n *\n * Note: Sub-objects in the path will not be `===` to objects in the same path in the existing data, but all\n *  other objects will be. By not cloning the data outside the path, we allow components (and Redux's connect\n *  HoC) to quickly tell which parts of the root object have changed, by doing a `===` comparison.\n *\n * TODO: Link to some documentation which will be a better explanation than the above\n *\n * @param {Array|string} path\n * @param {*} value\n * @param {Array|Object} object\n * @param {Number} level  How many times we've recursed\n * @return {Object} A new object with the appropriate value set\n */\nfunction baseSet(arrayPath, value, object, level = 0) {\n  if (level >= arrayPath.length) {\n    // We're at the end of our path; time to assign\n    return value;\n  }\n\n  const newObj = clone(object);\n\n  const pathSegment = arrayPath[level];\n  const nextPathSegment = arrayPath[level + 1];\n\n  // Handle a path that doesn't exist\n  if (typeof newObj[pathSegment] === 'undefined') {\n    // The type of this element depends on the next path chunk\n    switch (typeof nextPathSegment) {\n      case 'string':\n        newObj[pathSegment] = {};\n        break;\n      case 'number':\n        // The array should be big enough to get whatever index we're looking for\n        newObj[pathSegment] = new Array(nextPathSegment + 1);\n        break;\n      case 'undefined':\n        // Do nothing; this will be assigned on the next iteration\n        break;\n      default:\n        throw new Error(`Unrecognized path element type: ${typeof nextPathSegment}. Expected string or number. arrayPath[${level + 1}] contains ${nextPathSegment}.`);\n    }\n  }\n\n  newObj[pathSegment] = baseSet(arrayPath, value, newObj[pathSegment], level + 1);\n\n  return newObj;\n}\n\n\n/**\n * Sets the value at the end of the path, creating the appropriate objects along the way if needed.\n * Separate from `baseSet` to not expose the level param.\n *\n * @param {Array|string} path\n * @param {*} value\n * @param {Object} object\n * @return {Object} A new object with the appropriate value set\n */\nexport default function set(path, value, object) {\n  const arrayPath = Array.isArray(path) ? path : deconstructPath(path);\n  checkValidPath(arrayPath);\n  return baseSet(arrayPath, value, object, 0);\n}\n\n"]}