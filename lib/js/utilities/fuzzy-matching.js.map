{"version":3,"sources":["../../../src/js/utilities/fuzzy-matching.js"],"names":["sortListByFuzzyMatch","value","list","prop","map","label","option","toUpperCase","replace","val","score","includes","Infinity","Math","min","apply","split","fastLevenshtein","get","word","filter","wordScore","length","original","sort","a","b","result","sorted"],"mappings":";;;;;kBAEwBA,oB;;AAFxB;;;;;;AAEe,SAASA,oBAAT,CAA8BC,KAA9B,EAAqCC,IAArC,EAA2D;AAAA,MAAhBC,IAAgB,uEAAT,OAAS;;AACxE,SAAOD,KACJE,GADI,CACA,kBAAU;AACb,QAAMC,QAAQC,OAAOH,IAAP,EAAaI,WAAb,GAA2BC,OAA3B,CAAmC,aAAnC,EAAkD,EAAlD,CAAd;AACA,QAAMC,MAAMR,MAAMM,WAAN,GAAoBC,OAApB,CAA4B,aAA5B,EAA2C,EAA3C,CAAZ;AACA,QAAIE,QAAQL,MAAMM,QAAN,CAAeF,GAAf,IAAsB,CAAtB,GAA0BG,QAAtC;;AAEA;AACA;AACA,QAAIF,QAAQ,CAAR,IAAa,CAACD,IAAIE,QAAJ,CAAa,GAAb,CAAlB,EAAqC;AACnCD,cAAQG,KAAKC,GAAL,CAASC,KAAT,CAAe,IAAf,EACNV,MACGW,KADH,CACS,MADT,EAEGZ,GAFH,CAEO;AAAA,eAAQa,0BAAgBC,GAAhB,CAAoBC,IAApB,EAA0BV,GAA1B,CAAR;AAAA,OAFP,EAGGW,MAHH,CAGU;AAAA,eAAaC,YAAYZ,IAAIa,MAA7B;AAAA,OAHV,CADM,CAAR;AAMD,KAPD,MAOO,IAAIZ,QAAQ,CAAZ,EAAe;AACpBA,cAAQO,0BAAgBC,GAAhB,CAAoBb,KAApB,EAA2BI,GAA3B,CAAR;AACD;;AAED,WAAO;AACLC,kBADK;AAELa,gBAAUjB;AAFL,KAAP;AAID,GAvBI,EAwBJkB,IAxBI,CAwBC,UAACC,CAAD,EAAIC,CAAJ,EAAU;AACd,QAAMC,SAASF,EAAEf,KAAF,GAAUgB,EAAEhB,KAA3B;;AAEA,QAAIiB,WAAW,CAAf,EAAkB;AAChB,aAAOF,EAAEF,QAAF,CAAWpB,IAAX,EAAiBmB,MAAjB,GAA0BI,EAAEH,QAAF,CAAWpB,IAAX,EAAiBmB,MAAlD;AACD;;AAED,WAAOK,MAAP;AACD,GAhCI,EAiCJvB,GAjCI,CAiCA;AAAA,WAAUwB,OAAOL,QAAjB;AAAA,GAjCA,CAAP;AAkCD","file":"fuzzy-matching.js","sourcesContent":["import fastLevenshtein from 'fast-levenshtein';\n\nexport default function sortListByFuzzyMatch(value, list, prop = 'label') {\n  return list\n    .map(option => {\n      const label = option[prop].toUpperCase().replace(/[^a-zA-Z ]/g, '');\n      const val = value.toUpperCase().replace(/[^a-zA-Z ]/g, '');\n      let score = label.includes(val) ? 0 : Infinity;\n\n      // if the search term is just one word, split the\n      // list into words and find the best match\n      if (score > 0 && !val.includes(' ')) {\n        score = Math.min.apply(null,\n          label\n            .split(/[ ,]/)\n            .map(word => fastLevenshtein.get(word, val))\n            .filter(wordScore => wordScore < val.length)\n        );\n      } else if (score > 0) {\n        score = fastLevenshtein.get(label, val);\n      }\n\n      return {\n        score,\n        original: option\n      };\n    })\n    .sort((a, b) => {\n      const result = a.score - b.score;\n\n      if (result === 0) {\n        return a.original[prop].length - b.original[prop].length;\n      }\n\n      return result;\n    })\n    .map(sorted => sorted.original);\n}\n"]}